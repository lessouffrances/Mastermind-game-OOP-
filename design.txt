The design has three parts: 1. Structure Setup; 2. Game Implementation; 3. Game records and updates. 4. Dynamics.

1. Structure Setup: For the functions of the game, I imported 5 modules: turtle for general, sys for quit the game, time for gif display, and os.path for checking the existence of the file. I didn't modify the starting code but added the DocStrings. Starting codes were effectively used. I created a new class MyShape to register the gif on the turtle screen and make them clickable. Then I opened the class MasterMind and wrote the first block of the constructor, which is necessary and easy to think of. During the process of coding, the Methods of class MasterMind was gradually added and modified. In the second block of the constructor, I set up three boards, pegs, marbles and buttons. The data structure was not introduced in this lecture, but the matrix data structure is the best way I can think of to deal with the invisible relations of marbles. The data structure for option buttons (submit, reset and quit) is easier, I chose dictionary for the option buttons because the key cannot repeat. After the data structure is there, I set the marbles, pegs and options visually on boards by some trial and errors on paper to locate a best spot and by reusing the class Marble and MyShape. A moving pointer was set accordingly to move along each row. All those starting x and y are rigidly coded to fit in the frame. 

2. Game Implementation: The core of the game is to compare the current guess with the secret code to get the bulls and cows, and the function was created upfront to return the result of each round. The boolean values in the second code block of the constructor for button clicked and enabled is critical in the game implementation: True for clicked means the area is clicked, otherwise not clicked. True for enabled means the button is enabled, otherwise not enabled. These booleans work like 'switches' in the process of the game, to turn on/off the buttons and to check the user's gestures. I have a pair of functions check_color_button_clicked and check_color_buttons_clicked to catch the clicks on each round and transfer the colors onto the empty marbles. I have process_submit/reset/quit to process the game after the option buttons are clicked. The longest is process_submit, in which the pegs are colored, the results of the game are given with the counting of rounds going up. Process_reset/quit are easier, reset is to renew the choice tracker, recolor the buttons and clear the chosen colors while quit is just display a gif and exit. After process functions are settled, I have to check if the submit, reset or quit is actually clicked, so function check_option_buttons_clicked is there. Finally, I have function on_mouse_clicked to register all the clicks on canvas. 

3. Game records and updates: I set up the leaders board using the same way as other boards. And outside of the class MasterMind, I have a pair of functions: read and write leaders, basic file handling. But in read_leaders, I read the file as a list of tuples because in the class MasterMind I have another function update_leaders, in which the scores have to be sorted based on the 0 index of each tuple. After the read/write files are in place, I have update_leaders in class MasterMind to get new information, append new leaders and sort the list based on scores, and write to the files again. 

4. Dynamics: after going through the lines of code, readers will get the dynamics of how buttons are turn on\off, and the way that on/off relates to the next line of code. Also the dynamics exist in the way it tracks the guesses and rounds, also in reading, updating and writing to the leaders file. 

Note: the IDLE environment does not allow sys.exit(0), but I logically coded in Python that after clicking quit, the window should close automatically.